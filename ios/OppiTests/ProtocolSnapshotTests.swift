import XCTest
@testable import Oppi

/// Cross-platform protocol contract tests.
///
/// Decodes canonical ServerMessage JSON generated by the server test suite
/// (`server/tests/protocol-snapshots.test.ts`). If any message fails to decode,
/// the server and iOS are out of sync.
///
/// To regenerate the snapshot file:
///   cd server && npx vitest run tests/protocol-snapshots.test.ts
final class ProtocolSnapshotTests: XCTestCase {

    // MARK: - Snapshot Loading

    /// Path to the shared protocol snapshot file.
    private var snapshotURL: URL {
        // #filePath â†’ .../ios/OppiTests/ProtocolSnapshotTests.swift
        // Navigate up to repo root, then into protocol/
        let testFile = URL(fileURLWithPath: #filePath)
        let repoRoot = testFile
            .deletingLastPathComponent()  // OppiTests/
            .deletingLastPathComponent()  // ios/
            .deletingLastPathComponent()  // oppi/
        return repoRoot.appendingPathComponent("protocol/server-messages.json")
    }

    private func loadSnapshot() throws -> [String: Any] {
        let data = try Data(contentsOf: snapshotURL)
        let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] ?? [:]
        return json["messages"] as? [String: Any] ?? [:]
    }

    /// Decode a single message from the snapshot by key.
    private func decodeMessage(_ key: String) throws -> ServerMessage {
        let messages = try loadSnapshot()
        guard let value = messages[key] else {
            throw NSError(domain: "ProtocolSnapshot", code: 1, userInfo: [
                NSLocalizedDescriptionKey: "No snapshot for key '\(key)'"
            ])
        }
        let data = try JSONSerialization.data(withJSONObject: value)
        return try JSONDecoder().decode(ServerMessage.self, from: data)
    }

    // MARK: - Decode Every Message Type

    func testSnapshotFileExists() throws {
        XCTAssertTrue(
            FileManager.default.fileExists(atPath: snapshotURL.path),
            "Protocol snapshot not found at \(snapshotURL.path). Run: cd server && npx vitest run tests/protocol-snapshots.test.ts"
        )
    }

    func testDecodeAllServerMessages() throws {
        let messages = try loadSnapshot()

        var failures: [String] = []

        for (key, value) in messages {
            let messageJSON = try JSONSerialization.data(withJSONObject: value)
            do {
                let decoded = try JSONDecoder().decode(ServerMessage.self, from: messageJSON)

                // Verify we didn't fall through to .unknown
                switch decoded {
                case .unknown(let type):
                    // stream_connected is server-only (stream mux), iOS doesn't use it
                    if type != "stream_connected" {
                        failures.append("\(key): decoded as .unknown(\(type))")
                    }
                default:
                    break
                }
            } catch {
                failures.append("\(key): \(error.localizedDescription)")
            }
        }

        if !failures.isEmpty {
            XCTFail("Failed to decode \(failures.count) message(s):\n" + failures.joined(separator: "\n"))
        }
    }

    // MARK: - Specific Type Assertions

    func testConnectedMessage() throws {
        let msg = try decodeMessage("connected")

        guard case .connected(let session) = msg else {
            XCTFail("Expected .connected, got \(msg.typeLabel)")
            return
        }

        XCTAssertEqual(session.id, "test-session-1")
        XCTAssertEqual(session.status, .ready)
        XCTAssertEqual(session.workspaceId, "ws-1")
        XCTAssertEqual(session.workspaceName, "My Workspace")
        XCTAssertEqual(session.name, "Test Session")
        XCTAssertEqual(session.model, "anthropic/claude-sonnet-4-20250514")
        XCTAssertEqual(session.messageCount, 5)
        XCTAssertEqual(session.tokens.input, 1500)
        XCTAssertEqual(session.tokens.output, 800)
        XCTAssertEqual(session.cost, 0.012, accuracy: 0.001)
        XCTAssertEqual(session.contextTokens, 2300)
        XCTAssertEqual(session.contextWindow, 200000)
        XCTAssertEqual(session.thinkingLevel, "high")
        XCTAssertEqual(session.runtime, "host")
    }

    func testSessionChangeStats() throws {
        let msg = try decodeMessage("connected")

        guard case .connected(let session) = msg else {
            XCTFail("Expected .connected")
            return
        }

        let stats = session.changeStats
        XCTAssertNotNil(stats)
        XCTAssertEqual(stats?.mutatingToolCalls, 3)
        XCTAssertEqual(stats?.filesChanged, 2)
        XCTAssertEqual(stats?.changedFiles, ["src/main.ts", "README.md"])
        XCTAssertEqual(stats?.addedLines, 45)
        XCTAssertEqual(stats?.removedLines, 12)
    }

    func testPermissionRequest() throws {
        let msg = try decodeMessage("permission_request")

        guard case .permissionRequest(let perm) = msg else {
            XCTFail("Expected .permissionRequest, got \(msg.typeLabel)")
            return
        }

        XCTAssertEqual(perm.id, "perm-001")
        XCTAssertEqual(perm.sessionId, "test-session-1")
        XCTAssertEqual(perm.tool, "bash")
        XCTAssertEqual(perm.displaySummary, "Run: rm -rf node_modules")
        XCTAssertEqual(perm.risk, .high)
        XCTAssertEqual(perm.reason, "Destructive file operation")
        XCTAssertNotNil(perm.resolutionOptions)
        XCTAssertEqual(perm.resolutionOptions?.allowSession, true)
        XCTAssertEqual(perm.resolutionOptions?.allowAlways, true)
        XCTAssertEqual(perm.resolutionOptions?.denyAlways, true)
    }

    func testExtensionUIRequest() throws {
        let msg = try decodeMessage("extension_ui_request")

        guard case .extensionUIRequest(let req) = msg else {
            XCTFail("Expected .extensionUIRequest, got \(msg.typeLabel)")
            return
        }

        XCTAssertEqual(req.id, "ui-001")
        XCTAssertEqual(req.sessionId, "test-session-1")
        XCTAssertEqual(req.method, "select")
        XCTAssertEqual(req.title, "Choose a model")
        XCTAssertEqual(req.options, ["claude-sonnet", "claude-opus"])
    }

    func testTurnAck() throws {
        let msg = try decodeMessage("turn_ack")

        guard case .turnAck(let command, let clientTurnId, let stage, let requestId, let duplicate) = msg else {
            XCTFail("Expected .turnAck, got \(msg.typeLabel)")
            return
        }

        XCTAssertEqual(command, "prompt")
        XCTAssertEqual(clientTurnId, "turn-abc-123")
        XCTAssertEqual(stage, .accepted)
        XCTAssertEqual(requestId, "req-001")
        XCTAssertEqual(duplicate, false)
    }

    func testToolExecution() throws {
        // tool_start
        let startMsg = try decodeMessage("tool_start")
        guard case .toolStart(let tool, _, let toolCallId) = startMsg else {
            XCTFail("Expected .toolStart")
            return
        }
        XCTAssertEqual(tool, "bash")
        XCTAssertEqual(toolCallId, "tc-001")

        // tool_output
        let outputMsg = try decodeMessage("tool_output")
        guard case .toolOutput(let output, let isError, _) = outputMsg else {
            XCTFail("Expected .toolOutput")
            return
        }
        XCTAssertEqual(output, "All 42 tests passed")
        XCTAssertEqual(isError, false)

        // tool_end
        let endMsg = try decodeMessage("tool_end")
        guard case .toolEnd(let endTool, _) = endMsg else {
            XCTFail("Expected .toolEnd")
            return
        }
        XCTAssertEqual(endTool, "bash")
    }

    func testCompaction() throws {
        let startMsg = try decodeMessage("compaction_start")
        guard case .compactionStart(let reason) = startMsg else {
            XCTFail("Expected .compactionStart")
            return
        }
        XCTAssertEqual(reason, "Context window 85% full")

        let endMsg = try decodeMessage("compaction_end")
        guard case .compactionEnd(let aborted, let willRetry, let summary, let tokensBefore) = endMsg else {
            XCTFail("Expected .compactionEnd")
            return
        }
        XCTAssertEqual(aborted, false)
        XCTAssertEqual(willRetry, false)
        XCTAssertEqual(summary, "Compacted 15k tokens to 8k tokens")
        XCTAssertEqual(tokensBefore, 15000)
    }

    func testRetry() throws {
        let startMsg = try decodeMessage("retry_start")
        guard case .retryStart(let attempt, let maxAttempts, let delayMs, let errorMessage) = startMsg else {
            XCTFail("Expected .retryStart")
            return
        }
        XCTAssertEqual(attempt, 1)
        XCTAssertEqual(maxAttempts, 3)
        XCTAssertEqual(delayMs, 5000)
        XCTAssertEqual(errorMessage, "API overloaded")

        let endMsg = try decodeMessage("retry_end")
        guard case .retryEnd(let success, let endAttempt, _) = endMsg else {
            XCTFail("Expected .retryEnd")
            return
        }
        XCTAssertEqual(success, true)
        XCTAssertEqual(endAttempt, 2)
    }

    func testStopLifecycle() throws {
        let reqMsg = try decodeMessage("stop_requested")
        guard case .stopRequested(let source, _) = reqMsg else {
            XCTFail("Expected .stopRequested")
            return
        }
        XCTAssertEqual(source, .user)

        let confMsg = try decodeMessage("stop_confirmed")
        guard case .stopConfirmed = confMsg else {
            XCTFail("Expected .stopConfirmed")
            return
        }

        let failMsg = try decodeMessage("stop_failed")
        guard case .stopFailed(let failSource, let reason) = failMsg else {
            XCTFail("Expected .stopFailed")
            return
        }
        XCTAssertEqual(failSource, .timeout)
        XCTAssertTrue(reason.contains("SIGTERM"))
    }

    func testErrorMessage() throws {
        let msg = try decodeMessage("error")

        guard case .error(let message, let code, let fatal) = msg else {
            XCTFail("Expected .error")
            return
        }
        XCTAssertEqual(message, "Model API rate limit exceeded")
        XCTAssertEqual(code, "rate_limit")
        XCTAssertEqual(fatal, false)
    }

    // MARK: - Message Count Validation

    func testSnapshotCoversAllExpectedTypes() throws {
        let messages = try loadSnapshot()

        // All type discriminators that iOS handles (excluding stream_connected which is mux-only)
        let expectedTypes: Set<String> = [
            "connected", "state", "session_ended",
            "stop_requested", "stop_confirmed", "stop_failed", "error",
            "agent_start", "agent_end", "message_end",
            "text_delta", "thinking_delta",
            "tool_start", "tool_output", "tool_end",
            "turn_ack", "rpc_result",
            "compaction_start", "compaction_end",
            "retry_start", "retry_end",
            "permission_request", "permission_expired", "permission_cancelled",
            "extension_ui_request", "extension_ui_notification",
        ]

        let messageTypes = Set(messages.values.compactMap { value -> String? in
            guard let dict = value as? [String: Any] else { return nil }
            return dict["type"] as? String
        })

        let missing = expectedTypes.subtracting(messageTypes)
        XCTAssertTrue(missing.isEmpty, "Missing snapshots for types: \(missing.sorted())")
    }
}
